% $Id: todo.tex,v 1.3 2004/03/05 22:06:12 valeks Exp $
\documentclass[a4paper]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[T2C,T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{Список текущих задач}
\author{Валентин А. Алексеев}
%\sloppy
%\frenchspacing
\begin{document}
\chead{\bfseries НПП ``Новел-ИЛ''}
\lhead{$Revision: 1.3 $}
\chead{}
\rhead{Список текущих задач.}
\maketitle
\cfoot{\thepage}
\section{Критические}
\subsection{Ресурсные объекты ODISP}
{\bfseries ODISP, Решено (StandartResourceManager.java 1.12)}

{\bfseries Проблема:} быстрые частые перезапросы на захват и
высвобождение ресурса различными асинхронными объектами приводит к
ситуации, когда объект оставивший запрос не получает ресурса даже в
случае если тот находится в свободном состоянии.

{\bfseries Воспроизведение:} для тестирования данной ситуации написан
объект \verb+Racer+, который будучи запущенный в нескольких копиях пытается
получить доступ к одному и тому же ресурсу \verb+SimpleConfig+. На
данный момент проблема воспроизводится после $700 - 800$ успешных
завхватов ресурса объектом.

{\bfseries Локализация:} проблема возникает из-за конкурентного
асинхронного доступа различных нитей выполнения к внутренним свойствам
объекта \verb+StandartObjectManager+. Например, постановка сообщения
на захват в очередь одновременно с обработкой сообщения об освобождении.

{\bfseries Временные решения:} в качестве временного решения возможно
переделать использование ресурса с использованием разделения (флаг
$-1$ в \verb+classes.cfg+ и соответствующими дополнительными
объектами-обработчиками запросов).

{\bfseries Подходы к решению:} существует несколько подходов к решению
данной проблемы. Все они сводятся в основном к сведению к минимуму
перечня операций требующих захвата разделяемых переменных и
организации блокирования участков кода в блоках \verb+synchronized+.

{\bfseries Решение:} начиная с версии $1.12$ файла \verb+StandartResourceManager.java+
используется стратегия {\it DataThread} и все изменения над ресурсными
объектами производятся строго синхронно.

\section{Не критичные}
\subsection{Блокировка {\it dispatcher.send(\dots)}}
{\bfseries ODISP}

{\bfseries Проблема:} посылка сообщения объекту типа
\verb+CallbackODObject+ из объекта типа \verb+CallbackODObject+. В
связи с тем, что обработка сообщения для объектов типа \verb+Callback+
производится в той же нити выполнения, что и посылка -- вызов
\verb+send+ становится блокирующим на время выполнения обработчиков сообщений.

{\bfseries Воспроизведение:} файл \verb+GUIManager.java+ клиентской
части \verb+2NMS+ версии $1.21$. Флаг подтверждения получения ресурса
выставлялся после отсылки сообщения, которая выполняется
блокированно. По-этому сообщения пришедшие в момент после отсылки
сообщения, но до окончания выполнения всех обработчиков обрабатываются
некорректно.

{\bfseries Локализация:} проблема возникает из-за особенности
выполнения обработчиков для объектов типа \verb+Callback+.

{\bfseries Временные решения:} иметь ввиду возможность блокирования
обработчика при посылке сообщения. Необходимо так же следовать ODISP
Style Guide, который определяет объекты типа \verb+Callback+
исключительно как объекты для быстрой обработки строго определенного
набора сообщений. Более действенное решение предложено в реализациях
нитей данных (\verb+DataThread+) объектов \verb+nmslog+ и \verb+map+
серверной части пакета.

{\bfseries Подходы к решению:} существуют два независимых решения
данной проблемы. Первый сводится к использованию модели предложенной в
объектах \verb+nmslog+ или \verb+map+ (нить данных), а второй включает
в себя модификацию менеджера объектов таким образом, что бы доставка
сообщений происходила всегда без блокировки (отдельная нить для
передачи, либо отдельная нить для выполнения обработчика).

\subsection{Кэширование ответов на запросы}
{\bfseries ODISP}

{\bfseries Проблема:} на данный момент объекты типа \verb+map+ на
стороне сервера для каждого запроса свойства или списка объектов
обслуживаемых сервером.

{\bfseries Воспроизведение:} посылка сообщения
\verb+MapEnumerateObjectsMessage+ (\verb+map_enumerate_objects+)
приводит к перезапросу нитью данных значений из СУБД.

{\bfseries Локализация:} метод \verb+run()+ объекта
\verb+Log$DataThread+. %$ emacs hilight hack

{\bfseries Временные решения:} возможно использовать кэширование на
стороне объектов запрашивающих данные, как это сейчас реализовано в
объектах типа \verb+snmptrapd+ для сохранения обработчиков объектов.

{\bfseries Подходы к решению:} необходимо доработать схему нитей
данных и включить в реализацию проверку на повторный запрос и
сохранение сообщений в кэше нити. Так же следует продумать механизм
обновления и сброса значения кэша. См. так же ``Нити доступа к данным''.

\section{Долговременные}
\subsection{Контекст сообщения и ожидание сообщений}
{\bfseries ODISP}

{\bfseries Проблема:} модель асинхронных сообщений используемая в
ODISP на данный момент не позволяет простыми методами реализовывать
контекстно зависимую обработку сообщений. Так же близкой к этой
проблеме является необходимость реализации аналога \verb+chat+,
т.е. поддержка диалога между двумя или более объектами в стиле запрос
-- ожидание ответа определенного типа.

{\bfseries Воспроизведение:} например, реализация любого объекта,
которому необходимо знать об обработчиках устройств, на
стороне сервера до введения расширенного сообщения
\verb+MapEnumerateObjectsReplyMessage+ (до версии $1.16$ файла
\verb+DeviceMap.java+).

{\bfseries Локализация:} любой объект требующий большого количества
дополнительной информации от других объектов.

{\bfseries Временные решения:} не самым хорошим временным решением
является усложнение структуры сообщения пересылаемого между объектами,
как это было сделано в версии $1.17$ файла \verb+DeviceMap.java+.

{\bfseries Подходы к решению.} Решение данной проблемы сводится к
созданию двух дополнительных сервисов диспетчера -- сервиса сессий и
сервиса ожиданий. Возможно так же реализовать обратную совместимость
с объектами не поддерживающими сессии. Реализация ожидания сообщения
может быть сделана при помощи модели аналогичной той, что применяется
в Swing для обработки сообщений приходящих от объектов.

\subsection{Изменение механизма сборки и распространения}
{\bfseries ODISP/NMS}

{\bfseries Проблема:} механизм сборки используемый на данный момент в
ODISP и 2NMS не позволяется обеспечивать удобную раздельную сборку
компонентов системы. Так же цель \verb+release+ не подготавливает
полный набор файлов требуемых для запуска приложения (ресурсы, SSL
сертификаты, конфигурационные файлы). Подготавливаемый
набор файлов jar так же не удовлетворяет стандартному для UNIX-систем
расположению файлов по назначению.

{\bfseries Воспроизведение:} \verb+ant release+.

{\bfseries Локализация:} файл \verb+build.xml+ цели \verb+release+,
\verb+release-client+ и \verb+release-server+.

{\bfseries Временные решения:} единственным временным решением
является ручная доработка результатов сборки данных целей.

{\bfseries Подходы к решению.} Дальнейшее усложнение корневого файла
\verb+build.xml+ серьезно усложнить всю схему сборки, однако позволить
легче отслеживать зависимости между отдельными модулями. Возврат-же к
старой схеме с отдельными файлами \verb+build.xml+ для каждого из
компонент усложнит, например, раздельную сборку системы.

\subsection{Нити доступа к данным}
{\bfseries NMS/ODISP}

{\bfseries Проблема:} некоторые объекты ODISP и NMS используют схожую
по логике стратегию {\it DataThread}. Такой подход позволяет
обеспечить корректный синхронный доступ к какому либо разделяемому ресурсу
(соединение с базой данных, список объектов).

{\bfseries Локализация: } изменения затронут классы использующие на
данный момент подобную стратегию, а так же несколько дополнительных
классов в \verb+com.novel.common+.


{\bfseries Подходы к решению:} необходимо определить набор абстрактных
классов и интерфейсов, которые бы реализовывали стратегию в общем
виде. Так же на базе этой стратегии можно реализовать кеширование
отдельных запросов для ускорения их обработки.

\subsection{Сервис разрешения имен}
{\bfseries ODISP}

{\bfseries Проблема:} текущая реализация алгоритма отправки сообщения
не дает возможности объекту отослать сообщения не зная адресата (за
использования регулярных выражений в поле адресата).

{\bfseries Локализация: } изменения затронут
\verb+StandartObjectManager.java+ и несколько дополнительных файлов в 
\verb+com.novel.odisp+.

{\bfseries Временные решения:} возможно использовать регулярные
выражения и определить политику именования объектов реализующих какой
либо набор необходимых функций.

{\bfseries Подходы к решению:} реализация сервиса \verb+Discovery+,
который бы на основе данных о сервисах предоставляемых ресурсами
позволял бы разрешать имена для адресатов сообщений. Подобный сервис
упростил бы доставку сообщений уменьшив общее количество пересылаемых
сообщений за счет точного определения списка объектов реализующих
определенный сервис.

% Рыба для записи
% \subsection{Краткое название проблемы}
% {\bfseries модуль, статус решения}
%
% {\bfseries Проблема:} развернутое описание проблемы и причин ее
% возникновения
%
% {\bfseries Воспроизведение:} комманда или иной другой способ
% повторения проблемы
%
% {\bfseries Локализация:} файл или подсистема где возникает проблема
%
% {\bfseries Временные решения:} методика избежания проблемы до
% момента реализации какого либо подхода из следующего пункта.
%
% {\bfseries Подходы к решению:} краткое описание возможножных
% подходов к решению проблемы

\end{document}
