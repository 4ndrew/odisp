% $Id: todo.tex,v 1.1 2004/02/25 23:19:08 valeks Exp $
\documentclass[a4paper]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[T2C,T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{Список текущих задач}
\author{Валентин А. Алексеев}
%\sloppy
%\frenchspacing
\begin{document}
\chead{\bfseries НПП ``Новел-ИЛ''}
\lhead{$Revision: 1.1 $}
\chead{}
\rhead{Список текущих задач.}
\maketitle
\cfoot{\thepage}
\section{Критические}
\subsection{Ресурсные объекты ODISP}
{\bfseries Проблема:} быстрые частые перезапросы на захват и
высвобождение ресурса различными асинхронными объектами приводит к
ситуации, когда объект оставивший запрос не получает ресурса даже в
случае если тот находится в свободном состоянии.

{\bfseries Воспроизведение:} для тестирования данной ситуации написан
объект \verb+Racer+, который будучи запущенный в нескольких копиях пытается
получить доступ к одному и тому же ресурсу \verb+SimpleConfig+. На
данный момент проблема воспроизводится после $700 - 800$ успешных
завхватов ресурса объектом.

{\bfseries Локализация:} проблема возникает из-за конкурентного
асинхронного доступа различных нитей выполнения к внутренним свойствам
объекта \verb+StandartObjectManager+. Например, постановка сообщения
на захват в очередь одновременно с обработкой сообщения об освобождении.

{\bfseries Временные решения:} в качестве временного решения возможно
переделать использование ресурса с использованием разделения (флаг
$-1$ в \verb+classes.cfg+ и соответствующими дополнительными
объектами-обработчиками запросов).

{\bfseries Подходы к решению:} существует несколько подходов к решению
данной проблемы. Все они сводятся в основном к сведению к минимуму
перечня операций требующих захвата разделяемых переменных и
организации блокирования участков кода в блоках \verb+synchronized+.

\section{Не критичные}
\subsection{Блокировка {\it dispatcher.send(\dots)}}
{\bfseries Проблема:} посылка сообщения объекту типа
\verb+CallbackODObject+ из объекта типа \verb+CallbackODObject+. В
связи с тем, что обработка сообщения для объектов типа \verb+Callback+
производится в той же нити выполнения, что и посылка -- вызов
\verb+send+ становится блокирующим на время выполнения обработчиков сообщений.

{\bfseries Воспроизведение:} файл \verb+GUIManager.java+ клиентской
части \verb+2NMS+ версии $1.21$. Флаг подтверждения получения ресурса
выставлялся после отсылки сообщения, которая выполняется
блокированно. По-этому сообщения пришедшие в момент после отсылки
сообщения, но до окончания выполнения всех обработчиков обрабатываются
некорректно.

{\bfseries Локализация:} проблема возникает из-за особенности
выполнения обработчиков для объектов типа \verb+Callback+.

{\bfseries Временные решения:} иметь ввиду возможность блокирования
обработчика при посылке сообщения. Необходимо так же следовать ODISP
Style Guide, который определяет объекты типа \verb+Callback+
исключительно как объекты для быстрой обработки строго определенного
набора сообщений. Более действенное решение предложено в реализациях
нитей данных (\verb+DataThread+) объектов \verb+nmslog+ и \verb+map+
серверной части пакета.

{\bfseries Подходы к решению:} существуют два независимых решения
данной проблемы. Первый сводится к использованию модели предложенной в
объектах \verb+nmslog+ или \verb+map+ (нить данных), а второй включает
в себя модификацию менеджера объектов таким образом, что бы доставка
сообщений происходила всегда без блокировки (отдельная нить для
передачи, либо отдельная нить для выполнения обработчика).

\subsection{Кэширование ответов на запросы}
{\bfseries Проблема:} на данный момент объекты типа \verb+map+ на
стороне сервера для каждого запроса свойства или списка объектов
обслуживаемых сервером.

{\bfseries Воспроизведение:} посылка сообщения
\verb+MapEnumerateObjectsMessage+ (\verb+map_enumerate_objects+)
приводит к перезапросу нитью данных значений из СУБД.

{\bfseries Локализация:} метод \verb+run()+ объекта
\verb+Log$DataThread+. %$ emacs hilight hack

{\bfseries Временные решения:} возможно использовать кэширование на
стороне объектов запрашивающих данные, как это сейчас реализовано в
объектах типа \verb+snmptrapd+ для сохранения обработчиков объектов.

{\bfseries Подходы к решению:} необходимо доработать схему нитей
данных и включить в реализацию проверку на повторный запрос и
сохранение сообщений в кэше нити. Так же следует продумать механизм
обновления и сброса значения кэша.

\section{Долговременные}
\subsection{Контекст сообщения и ожидание сообщений}

{\bfseries Проблема:} модель асинхронных сообщений используемая в
ODISP на данный момент не позволяет простыми методами реализовывать
контекстно зависимую обработку сообщений. Так же близкой к этой
проблеме является необходимость реализации аналога \verb+chat+,
т.е. поддержка диалога между двумя или более объектами в стиле запрос
-- ожидание ответа определенного типа.

{\bfseries Воспроизведение:} например, реализация любого объекта,
которому необходимо знать об обработчиках устройств, на
стороне сервера до введения расширенного сообщения
\verb+MapEnumerateObjectsReplyMessage+ (до версии $1.16$ файла
\verb+DeviceMap.java+).

{\bseries Локализация:} любой объект требующий большого количества
дополнительной информации от других объектов.

{\bfseries Временные решения:} не самым хорошим временным решением
является усложнение структуры сообщения пересылаемого между объектами,
как это было сделано в версии $1.17$ файла \verb+DeviceMap.java+.

{\bfseries Подходы к решению.} Решение данной проблемы сводится к
созданию двух дополнительных сервисов диспетчера -- сервиса сессий и
сервиса ожиданий. Возможно так же реализовать обратную совместимость
с объектами не поддерживающими сессии. Реализация ожидания сообщения
может быть сделана при помощи модели аналогичной той, что применяется
в Swing для обработки сообщений приходящих от объектов.

\subsection{Изменение механизма сборки и распространения}
{\bfseries Проблема:} механизм сборки используемый на данный момент в
ODISP и 2NMS не позволяется обеспечивать удобную раздельную сборку
компонентов системы. Так же цель \verb+release+ не подготавливает
полный набор файлов требуемых для запуска приложения (ресурсы, SSL
сертификаты, конфигурационные файлы). Подготавливаемый
набор файлов jar так же не удовлетворяет стандартному для UNIX-систем
расположению файлов по назначению.

{\bfseries Воспроизведение:} \verb+ant release+.

{\bfseries Локализация:} файл \verb+build.xml+ цели \verb+release+,
\verb+release-client+ и \verb+release-server+.

{\bfseries Временные решения:} единственным временным решением
является ручная доработка результатов сборки данных целей.

{\bfseries Подходы к решению.} Дальнейшее усложнение корневого файла
\verb+build.xml+ серьезно усложнить всю схему сборки, однако позволить
легче отслеживать зависимости между отдельными модулями. Возврат-же к
старой схеме с отдельными файлами \verb+build.xml+ для каждого из
компонент усложнит, например, раздельную сборку системы.

% Рыба для записи
% \subsection{Краткое название проблемы}
% {\bfseries Проблема:} развернутое описание проблемы и причин ее возникновения
% {\bfseries Воспроизведение:} комманда или иной другой способ
% повторения проблемы
% {\bfseries Локализация:} файл или подсистема где возникает проблема
% {\bfseries Временные решения:} методика избежания проблемы до
% момента реализации какого либо подхода из следующего пункта.
% {\bfseries Подходы к решению:} краткое описание возможножных
% подходов к решению проблемы

\end{document}
