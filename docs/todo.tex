% $Id: todo.tex,v 1.5 2004/04/21 14:24:35 dron Exp $
\documentclass[a4paper]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[T2C,T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{Список текущих задач}
\author{Валентин А. Алексеев}
%\sloppy
%\frenchspacing
\begin{document}
\chead{\bfseries НПП ``Новел-ИЛ''}
\lhead{$Revision: 1.5 $}
\chead{}
\rhead{Список текущих задач.}
\maketitle
\cfoot{\thepage}
\section{Критические}
\subsection{Ресурсные объекты ODISP}
{\bfseries ODISP, Решено (StandartResourceManager.java 1.12)}

{\bfseries Проблема:} быстрые частые перезапросы на захват и
высвобождение ресурса различными асинхронными объектами приводит к
ситуации, когда объект оставивший запрос не получает ресурса даже в
случае если тот находится в свободном состоянии.

{\bfseries Воспроизведение:} для тестирования данной ситуации написан
объект \verb+Racer+, который будучи запущенный в нескольких копиях пытается
получить доступ к одному и тому же ресурсу \verb+SimpleConfig+. На
данный момент проблема воспроизводится после $700 - 800$ успешных
завхватов ресурса объектом.

{\bfseries Локализация:} проблема возникает из-за конкурентного
асинхронного доступа различных нитей выполнения к внутренним свойствам
объекта \verb+StandartObjectManager+. Например, постановка сообщения
на захват в очередь одновременно с обработкой сообщения об освобождении.

{\bfseries Временные решения:} в качестве временного решения возможно
переделать использование ресурса с использованием разделения (флаг
$-1$ в \verb+classes.cfg+ и соответствующими дополнительными
объектами-обработчиками запросов).

{\bfseries Подходы к решению:} существует несколько подходов к решению
данной проблемы. Все они сводятся в основном к сведению к минимуму
перечня операций требующих захвата разделяемых переменных и
организации блокирования участков кода в блоках \verb+synchronized+.

{\bfseries Решение:} начиная с версии $1.12$ файла \verb+StandartResourceManager.java+
используется стратегия {\it DataThread} и все изменения над ресурсными
объектами производятся строго синхронно.

\section{Не критичные}
\subsection{Блокировка {\it dispatcher.send(\dots)}}
{\bfseries ODISP}

{\bfseries Проблема:} посылка сообщения объекту типа
\verb+CallbackODObject+ из объекта типа \verb+CallbackODObject+. В
связи с тем, что обработка сообщения для объектов типа \verb+Callback+
производится в той же нити выполнения, что и посылка -- вызов
\verb+send+ становится блокирующим на время выполнения обработчиков сообщений.

{\bfseries Воспроизведение:} файл \verb+GUIManager.java+ клиентской
части \verb+2NMS+ версии $1.21$. Флаг подтверждения получения ресурса
выставлялся после отсылки сообщения, которая выполняется
блокированно. По-этому сообщения пришедшие в момент после отсылки
сообщения, но до окончания выполнения всех обработчиков обрабатываются
некорректно.

{\bfseries Локализация:} проблема возникает из-за особенности
выполнения обработчиков для объектов типа \verb+Callback+.

{\bfseries Временные решения:} иметь ввиду возможность блокирования
обработчика при посылке сообщения. Необходимо так же следовать ODISP
Style Guide, который определяет объекты типа \verb+Callback+
исключительно как объекты для быстрой обработки строго определенного
набора сообщений. Более действенное решение предложено в реализациях
нитей данных (\verb+DataThread+) объектов \verb+nmslog+ и \verb+map+
серверной части пакета.

{\bfseries Подходы к решению:} существуют два независимых решения
данной проблемы. Первый сводится к использованию модели предложенной в
объектах \verb+nmslog+ или \verb+map+ (нить данных), а второй включает
в себя модификацию менеджера объектов таким образом, что бы доставка
сообщений происходила всегда без блокировки (отдельная нить для
передачи, либо отдельная нить для выполнения обработчика).

\subsection{Кэширование ответов на запросы}
{\bfseries ODISP}

{\bfseries Проблема:} на данный момент объекты типа \verb+map+ на
стороне сервера для каждого запроса свойства или списка объектов
обслуживаемых сервером.

{\bfseries Воспроизведение:} посылка сообщения
\verb+MapEnumerateObjectsMessage+ (\verb+map_enumerate_objects+)
приводит к перезапросу нитью данных значений из СУБД.

{\bfseries Локализация:} метод \verb+run()+ объекта
\verb+Log$DataThread+. %$ emacs hilight hack

{\bfseries Временные решения:} возможно использовать кэширование на
стороне объектов запрашивающих данные, как это сейчас реализовано в
объектах типа \verb+snmptrapd+ для сохранения обработчиков объектов.

{\bfseries Подходы к решению:} необходимо доработать схему нитей
данных и включить в реализацию проверку на повторный запрос и
сохранение сообщений в кэше нити. Так же следует продумать механизм
обновления и сброса значения кэша. См. так же ``Нити доступа к данным''.

\section{Долговременные}
\subsection{Контекст сообщения и ожидание сообщений}
{\bfseries ODISP}

{\bfseries Проблема:} модель асинхронных сообщений используемая в
ODISP на данный момент не позволяет простыми методами реализовывать
контекстно зависимую обработку сообщений. Так же близкой к этой
проблеме является необходимость реализации аналога \verb+chat+,
т.е. поддержка диалога между двумя или более объектами в стиле запрос
-- ожидание ответа определенного типа.

{\bfseries Воспроизведение:} например, реализация любого объекта,
которому необходимо знать об обработчиках устройств, на
стороне сервера до введения расширенного сообщения
\verb+MapEnumerateObjectsReplyMessage+ (до версии $1.16$ файла
\verb+DeviceMap.java+).

{\bfseries Локализация:} любой объект требующий большого количества
дополнительной информации от других объектов.

{\bfseries Временные решения:} не самым хорошим временным решением
является усложнение структуры сообщения пересылаемого между объектами,
как это было сделано в версии $1.17$ файла \verb+DeviceMap.java+.

{\bfseries Подходы к решению.} Решение данной проблемы сводится к
созданию двух дополнительных сервисов диспетчера -- сервиса сессий и
сервиса ожиданий. Возможно так же реализовать обратную совместимость
с объектами не поддерживающими сессии. Реализация ожидания сообщения
может быть сделана при помощи модели аналогичной той, что применяется
в Swing для обработки сообщений приходящих от объектов.

\subsection{Изменение механизма сборки и распространения}
{\bfseries ODISP/NMS}

{\bfseries Проблема:} механизм сборки используемый на данный момент в
ODISP и 2NMS не позволяется обеспечивать удобную раздельную сборку
компонентов системы. Так же цель \verb+release+ не подготавливает
полный набор файлов требуемых для запуска приложения (ресурсы, SSL
сертификаты, конфигурационные файлы). Подготавливаемый
набор файлов jar так же не удовлетворяет стандартному для UNIX-систем
расположению файлов по назначению.

{\bfseries Воспроизведение:} \verb+ant release+.

{\bfseries Локализация:} файл \verb+build.xml+ цели \verb+release+,
\verb+release-client+ и \verb+release-server+.

{\bfseries Временные решения:} единственным временным решением
является ручная доработка результатов сборки данных целей.

{\bfseries Подходы к решению.} Дальнейшее усложнение корневого файла
\verb+build.xml+ серьезно усложнить всю схему сборки, однако позволить
легче отслеживать зависимости между отдельными модулями. Возврат-же к
старой схеме с отдельными файлами \verb+build.xml+ для каждого из
компонент усложнит, например, раздельную сборку системы.

\subsection{Нити доступа к данным}
{\bfseries NMS/ODISP}

{\bfseries Проблема:} некоторые объекты ODISP и NMS используют схожую
по логике стратегию {\it DataThread}. Такой подход позволяет
обеспечить корректный синхронный доступ к какому либо разделяемому ресурсу
(соединение с базой данных, список объектов).

{\bfseries Локализация: } изменения затронут классы использующие на
данный момент подобную стратегию, а так же несколько дополнительных
классов в \verb+com.novel.common+.


{\bfseries Подходы к решению:} необходимо определить набор абстрактных
классов и интерфейсов, которые бы реализовывали стратегию в общем
виде. Так же на базе этой стратегии можно реализовать кеширование
отдельных запросов для ускорения их обработки.

\subsection{Конфигурация объектов и ресурсов}
{\bfseries ODISP. Решено: StandartDispatcher.java:1.36 и др.}

{\bfseries Проблема:} многие объекты и ресурсы ODISP и NMS требуют некоторую
начальную конфигурацию.

{\bfseries Локализация: } изменения затронут механизм загрузки объектов и ресурсов
в \verb+StandartDispatcher.java+, а так же интерфейсы и методы \verb+ODObject+
и \verb+Resource+.


{\bfseries Подходы к решению:} необходимо использовать какой-либо расширяемый
формат представления файла \verb+classes.cfg+, например XML.

\subsection{Сервис разрешения имен}
{\bfseries ODISP, Решено: StandartObjectManager.java:1.11 и др. Коммит запись \No 904.}

{\bfseries Проблема:} текущая реализация алгоритма отправки сообщения
не дает возможности объекту отослать сообщения не зная адресата (за
использования регулярных выражений в поле адресата).

{\bfseries Локализация: } изменения затронут
\verb+StandartObjectManager.java+ и несколько дополнительных файлов в 
\verb+com.novel.odisp+.

{\bfseries Временные решения:} возможно использовать регулярные
выражения и определить политику именования объектов реализующих какой
либо набор необходимых функций.

{\bfseries Подходы к решению:} реализация сервиса \verb+Discovery+,
который бы на основе данных о сервисах предоставляемых ресурсами
позволял бы разрешать имена для адресатов сообщений. Подобный сервис
упростил бы доставку сообщений уменьшив общее количество пересылаемых
сообщений за счет точного определения списка объектов реализующих
определенный сервис.

\subsection{Конфигурация ресурсов при создании}
{\bfseries ODISP, рассматривается}

{\bfseries Проблема:} Для конфигурирования объектов и ресурсов используется
единый конфигурационный файл. Это есть хорошо. Но существует часть ресурсов,
которые проходят стадиюд конфигурации при создании, тоесть в конструкторе
ресурса. Поэтому они не могут использовать конфигурационные данные.

{\bfseries Воспроизведение:} No comments.

{\bfseries Локализация:} com.novel.messages.Resource

{\bfseries Временные решения:} Использование объектов-конфигураторов (не имеет
выгоды, так как теряются преимущества конфигурационного файла).

{\bfseries Подходы к решению:} Возможно не плохим решением бы было введение
нового метода в ресурсе, который бы вызывался после конструктора (например
\verb+initResource()+).

\subsection{Плавное обновление объектов}
{\bfseries 2NMS Client, рассматривается}

{\bfseries Проблема:} При тестировании 2NMS пакета на критическом количестве
объектов наблюдается резкий рост времени загрузки объектов с клиента на
сервер. Проблема состоит в том, что на клиентской части при соединении
запрашивается весь список объектов, плюс значения всех свойств каждого
объекта. Это есть плохо.

{\bfseries Воспроизведение:} База с 50000 объектов + 2NMS server + 2NMS Client
и бутылку-две-три-ящик пива, чтобы скрасить ожидание....

{\bfseries Локализация:} объекты Odisp: MapGUI, DeviceList, InfoGUI.

{\bfseries Временные решения:} временное решение очень простое:
\begin{quote}
- Доктор, когда вот так делаю, у меня вот там болит.\\
- Не делайте так.\\
:-D
\end{quote}

{\bfseries Подходы к решению:} Для решения проблемы предлагается сделать
некоторое логическое разделение информации об объектах. Пусть это будет три
группы:
\begin{enumerate}
\item Критически важные данные (Список объектов, уровень (путь) расположения).
\item Данные отображения (Расположение на карте, EquipmentStatus, Links, etc),
данные которые используются джля отображения объекта на карте.
\item Полные данные (Всё остальное)

Присоединении, клиентскоая сторона должна послать запрос на список объектов
(со всех уровней, тоесть групп), на данном этапе использование отложенного
обновления сильно усложнит возможности локации объектов на карте. При показе
какого-либо уровня карты, клиент должен запрашивать "Данные отображения", ну и
при редактировании или просмотре информации об объекте клиент запрашивает
остальную информацию.

Кстати, на счёт оптимизации просмотра свойств объекта придумалось что-нить
взять из идее версионной базы данных (но пока забилось) :-D
\end{enumerate}

% Рыба для записи
% \subsection{Краткое название проблемы}
% {\bfseries модуль, статус решения}
%
% {\bfseries Проблема:} развернутое описание проблемы и причин ее
% возникновения
%
% {\bfseries Воспроизведение:} комманда или иной другой способ
% повторения проблемы
%
% {\bfseries Локализация:} файл или подсистема где возникает проблема
%
% {\bfseries Временные решения:} методика избежания проблемы до
% момента реализации какого либо подхода из следующего пункта.
%
% {\bfseries Подходы к решению:} краткое описание возможножных
% подходов к решению проблемы

\end{document}
