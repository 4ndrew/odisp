% $Id: odisp-style.tex,v 1.5 2004/03/14 12:43:25 dron Exp $
\documentclass[a4paper]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[T2C,T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{ODISP. Модель и реализация}
\author{Валентин А. Алексеев}
%\sloppy
\frenchspacing
\begin{document}
\chead{\bfseries НПП ``Новел-ИЛ''}
\vbox{
  \vskip .35 \textheight
  \begin{center}
    Валентин А. Алексеев\\*
    Андрей А. Порохин\\*
    \bfseries{\Large ODISP. Модель и реализация.}
  \end{center}
}
\cfoot{Санкт-Петербург \\* 2003-2004}
\newpage
\lhead{$Revision: 1.5 $}
\chead{}
\rhead{ODISP. Модель и реализация.}
\cfoot{\thepage}
\tableofcontents
\newpage
\section{Модель}
\subsection{Краткое описание}
ODISP это полностью асинхронная транспортная система без ведения сессий. За основу
были взяты некоторые идеи реализации микроядерных операционных систем и систем 
организации распределенных вычислений.

В основе модели диспетчера объектов лежит метод передачи сообщений между отдельными,
логически цельными, модулями. Каждый модуль имеет связь с диспетчером и почтовый
ящик для приходящих сообщений. Сообщения между модулями служат исключительно для
передачи данных (уведомления). 

Основная деятельность модулей происходит в дочерних объектах. Объекты реализующие 
функции почтовых ящиков стоит воспринимать исключительно как порты для приема сообщений.

\subsection{Диспетчер}
Ядро системы ODISP состоит из диспетчера сообщений (stddispatcher) и объектов
реализующих различные стратегии обработки сообщений (порты), интерфейсов ресурсных
объектов и сообщений.

Основные задачи диспетчера объектов:
\begin{itemize}
  \item первоначальный запуск системы, чтение списка объектов и ресурсов
  \item загрузка объектов и ресурсов в порядке их следования в конфигурационном файле
  \item отслеживание зависимостей объектов по предоставляемой ими информации
  \item обеспечение конкурентного доступа к ресурсным объектам (блокирующий и не блокирующий
    захват ресурсов)
  \item отслеживание максимально разрешенного количества запущенных экземпляров ресурса
  \item обеспечение корректной выгрузки объектов и ресурсов
\end{itemize}

\subsection{Сообщения}
Каждое сообщение в ODISP идентифицируется своим уникальным (в пределах одного диспетчера 
и виртуальной машины) индексом. Специально зарезервирован номер 0 -- сообщения с этим
номером начинают сессию.

Конверт сообщения содержит поле действия (action), поле отправителя (origin), 
поле получателя (destination) и индекс сообщения, на которое производится ответ.

Сообщение может нести любое количество дополнительных параметров. Смысловая нагрузка параметров
определяется действием (action) и интерпретируется получателем.

Диспетчер не вмешивается в структуру сообщения. Он обеспечивает лишь транспортный уровень.

\subsection{Модули}
Главной единицей в ODISP является модуль (объект ODISP). Именно такой объект реализует
реальную задачу выполняемую системой.

Каждый модуль имеет возможность получать и отсылать любые сообщения в ядре ODISP.
Какие конкретно сообщения будет обрабатывать модуль зависит от стратегии.

\subsection{Ресурсы}
Еще один тип данных с которым работает диспетчер -- ресурс. Объект реализующий
интерфейс ресурса не может получать или посылать ODISP-сообщения. Такой объект
может быть либо хранилищем данных (хранилище в терминах DFD) либо обложкой для внешнего
сложного объекта, которым требуется управлять непосредственно (ресурсы-шлюзы).

Основным назначением ресурсов является именно хранение и, как частный случай, отображение 
данных.

\subsection{Ресурсы-шлюзы}
Ресурсы, работающие в качестве шлюзов реализуют разделяемый доступ к сложным внешним объектам,
которые из-за объема интерфейса проще не инкапсулировать в обычный ресурсный объект.

\section{Реализация}
Текущая реализация объектного диспетчера написана на языке Java версии 1.4.1.

Она содержит в себе набор вспомогательных объектов, которые реализуют базовые
функции. Среди них: консоль управления диспетчером (console), систему файловой журнализации
сообщений (log), объект-эхо (echo) для тестов. Также реализован ресурсный объект обеспечивающий
доступ к простейшему файлу конфигурации (simpleconfig). Эти модули и ресурсы можно использовать
как эталонные реализации отдельных стратегий.


\subsection{Соглашения об именовании}
При работе с ODISP необходимо придерживаться следующих правил именования:
\begin{itemize}
  \item внутреннее имя объекта ODISP должно содержать лишь символы английского алфавита и должно
    нести краткое описание назначения объекта (\verb+devgensnmp+ -- типовое SNMP устройство)
  \item название действия должно начинаться с префикса подсистемы. логические части названия
    должны разделятся символом ``\_'' (\verb+od_remove_dep+ -- убрать зависимость из списка)
  \item для обеспечения возможности загрузки одновременно нескольких одинаковых модулей внутреннее имя
    конструируется из имени модуля и уникального индекса (\verb+log0+, \verb+console1+).
\end{itemize}

\subsection{Стандартный диспетчер}
Текущая реализация диспетчера ODISP (stddispatcher) реализует все поставленные
в модели задачи за исключением отслеживания максимального количества экземпляров
ресурсных объектов.

Запуск системы возможен напрямую из виртуальной машины. В качестве обязательного
параметра диспетчер принимает имя файла содержащего конфигурацию объектов для решения
конкретной задачи.

Загрузка объектов осуществляется в соответствии с их порядком в конфигурационном файле.
Первым всегда запускается модуль обрабатывающий внутренние запросы ядра ODISP: \verb+od_acquire+,
\verb+od_release+, \verb+od_shutdown+ и т.п. 

После загрузки очередного модуля диспетчер запрашивает у объекта список зависимостей и, 
в случае если все зависимости выполнены, запускает объект на выполнение посылкой сообщения
\verb+od_object_loaded+. После запуска диспетчер запрашивает у модуля список сервисов,
которые он предоставляет. Для ресурсных объектов список состоит из одного элемента -- имени
класса.

Конкурирующий доступ объектов к ресурсам обеспечивается за счет хранения очередей заявок 
объектов на ресурсы. При высвобождении ресурса (или в начале работы) из очереди 
выбирается первый ожидающий ресурс. Будет ли захват ресурса блокирующим определяется через
дополнительный параметр запроса ресурса. В то время как статус блокировки объекта определяется
как ``блокированный'', сообщения ODISP для него не отсылаются, а запоминаются в очереди
сообщений. На данный момент существует одно серьезное ограничений -- каждое высвобождение
ресурса считается уменьшением статуса блокировки.

Для обеспечения корректного завершения всеми объектами своей работы при выгрузке системы диспетчер реализует
обработку специального сообщения \verb+od_shutdown+, которая инициирует процесс последовательной выгрузки
объектов с предварительной посылкой им сообщения \verb+od_cleanup+ с необязательным параметром -- кодом
выхода.

\subsection{Стандартное сообщение}
Для передачи сообщений между модулями используются экземпляры класса \verb+StandartMessage+, который
реализует интерфейс \verb+Message+.

Данные в заголовке сообщения представляют собой набор текстовых полей, которые идентифицируют действие,
получателя и отправителя, а так же поле индекса сообщения, на которое производится ответ.

Внутренне данные сообщения представляются в виде списка с доступом по индексу. Никаких действий не 
предпринимается для того, что бы определить и избежать возникновения исключительных ситуаций.

Для того, что бы определить назначение полей и их тип, получатель должен знать структуру данных
для данного типа действия. Для автоматического приведения типов и замены индексов на некоторые значимые
символьные имена, вводится понятие Typed Messages.

\subsection{Типизированные сообщения}
Типизированные сообщения или Typed Messages помогают привязать логическую нагрузку данных передаваемых
в сообщении к типу действия.

Каждый объект -- типизированное сообщение -- обязан расширять класс \verb+StandartMessage+ для того, 
что бы обеспечить прозрачность работы диспетчера и упростить обработку сообщений, например, при их 
подготовке к передаче по сети.

Для формализации создания типизированных сообщений предлагается использовать соглашения об именовании 
get/set/is методов технологии JavaBeans.

%\subsection{Модули ODISP}

\subsection{Стратегии обработки}
В текущей реализации определено две основных стратегии обработки сообщений. Каждая из стратегий дает
преимущество для тех или иных задач, которые выполняются модулем. 
Модуль может определить, сообщения с каким адресатом он может обрабатывать. Изначально эта маска, как
регулярное выражение, имеет вид ``\verb+имяобъекта.*+''

\subsubsection{Опросная стратегия}
Модули, реализующие опросную модель, наследуют класс \verb+PollingODObjcet+ и должны реализовать
абстрактный метод \verb+handleMessage+.

При использовании данной стратегии именно модуль решает, какие из приходящих сообщений он в состоянии
обработать.

Данную стратегию целесообразно применять в том случае если требуется максимально быстро отвечать на
приходящие сообщения. Эта стратегия использует дополнительный поток выполнения для циклического
опроса состояния порта.

\subsubsection{Стратегия обработчиков}
Другой подход реализуется через наследование класса \verb+CallbackODObject+. В этом случае модуль
должен реализовывать абстрактный метод \verb+registerHandlers+. В котором, в свою очередь, модуль
должен, последовательно вызывая метод \verb+addHandler+, зарегистрировать отдельные обработчики сообщений
для каждого конкретного действия.

Каждый обработчик сообщения это класс реализующий интерфейс \verb+MessageHandler+.

Данная стратегия может быть использована для реализации сервисных функций системы (работа с конфигурацией и т.п.).

Использовать эту стратегию следует осторожно, так как на время выполнения функции-обработчика объект
пославший сообщение блокируется.

\subsection{Выбор реализации}
Модули и ресурсы ODISP позволяют охватить большую область применения. Основным правилом, которым
следует руководствоваться при создании модулей и ресурсов является ``пусть каждый делает свое, хоть и малое,
дело, но делает его хорошо''. Так же приветствуется идеология фильтров, которые позволят конструировать системы
любой сложности из чрезвычайно простых элементов.

Если брать за основу DFD диаграмму (диаграмму потоков данных), то выбор конкретной реализации может 
осуществляться следующим образом:
\begin{itemize}
  \item \begin{it}внешняя сущность\end{it} и \begin{it}процессы\end{it} со входом и выходом
      -- модули реализующие PollingODObject стратегию
  \item \begin{it}процесс\end{it} имеющий только входной поток -- модуль с CallbackODObject стратегией
  \item \begin{it}хранилище\end{it} -- ресурсный объект
\end{itemize}
Однако такое соответствие неоднозначно, так как в основном выбор, например, стратегии зависит от класса
задач выполняемых модулем.

\subsection{Эталонные реализации}
За эталонные реализации тех или иных понятий ODISP стоит брать следующие объекты:
\begin{itemize}
  \item опросная стратегия -- \verb+FileLog+ (смена маски обрабатываемых сообщений,
    работа с ресурсами).
  \item стратегия обработчиков -- \verb+StandartDispatcherHandler+ и \verb+Echo+
    (работа с \verb+registerHandlers+, реализация \verb+MessageHandler+ интерфейса)
  \item ресурсы -- \verb+SimpleConfig+
  \item дочерние объектов -- пакет \verb+com.novel.nms.server.conn+ (работа с
    диспетчером в дочерних объектах, адресация отдельных дочерних объектов)
\end{itemize}

\subsection{Возможные проблемы}
\subsubsection{Необходимость синхронизации}
При использовании \verb+CallbackODObject+ модели обработки сообщений
необходимо учесть то, что функции обработки сообщений выполняются асинхронно
в контексте различных потоков приложения. Поэтому при использовании каких-либо
полей объекта необходимо продумать использование синхронизации относительно
этих полей, чтобы решить проблему конкурентного доступа.

\subsubsection{CallbackODObject и сообщения ``запрос-ответ''}
При использовании ODISP часто существует необходимость в использовании
механизма ``запрос-ответ'' (объект запрашивает какую-либо информацию и ему
приходит ответ на этот запрос). Если объекты используют в качестве стратегии
обработки сообщений \verb+CallbackODObject+, то возникает ситуация, когда тот
же поток (thread), который послал сообщение является транспортным для доставки
ответа. Поэтому всегда необходимо учитывать этот случай при использовании
синхронизации относительно относительно полей объекта. Так же крайне не
рекомендуется посылать сообщения ODISP из \verb+synchronized+ методов
объекта, так как это может привести к появлению взаимной блокировки
(deadlock).

В качестве решения этой проблемы так же можно отделить транспортные средства
диспетчера от объекта источника, то есть сообщение должно доставляться в другом
потоке (не реализовано в стандартном диспетчере).

\section{Перспективы развития}
Своей реализации ожидают следующие возможности:
\begin{itemize}
  \item предварительная конфигурация объекта перед запуском на основании данных конфигурационного файла
  \item реализация большего количества примитивных объектов
  \item создание объектов со стратегией обработчиков на основе соглашений об именовании JavaBeans и 
    пакета \verb+java.lang.reflect+
  \item обеспечение совместимости с существующими системами распределенных вычислений (Corba, EJB, COM)
\end{itemize}

\end{document}
