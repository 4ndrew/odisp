% $Id: odisp-style.tex,v 1.7 2004/08/18 12:48:39 valeks Exp $
% (C) 2003-2004 Valentin A. Alekseev
% (C) 2003-2004 Andrew A. Porohin
\documentclass[a4paper]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[T2C,T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{ODISP. Модель и реализация}
\author{Валентин А. Алексеев}
%\sloppy
\frenchspacing
\begin{document}
\chead{\bfseries VAleks LABs}
\vbox{
  \vskip .35 \textheight
  \begin{center}
    Валентин А. Алексеев\\*
    Андрей А. Порохин\\*
    \bfseries{\Large ODISP. Модель и реализация.}
  \end{center}
}
\cfoot{Санкт-Петербург \\* 2003-2004}
\newpage
\lhead{$Revision: 1.7 $}
\chead{}
\rhead{ODISP. Модель и реализация.}
\cfoot{\thepage}
\tableofcontents
\newpage
\section{Модель}
\subsection{Краткое описание}
ODISP это полностью асинхронная транспортная система без ведения сессий. За основу
были взяты некоторые идеи реализации микроядерных операционных систем и систем 
организации распределенных вычислений.

В основе модели диспетчера объектов лежит метод передачи сообщений между отдельными,
логически цельными, модулями. Каждый модуль имеет связь с диспетчером и почтовый
ящик для приходящих сообщений. Сообщения между модулями служат исключительно для
передачи данных (уведомления). 

Основная деятельность модулей происходит в дочерних объектах. Объекты реализующие 
функции почтовых ящиков стоит воспринимать исключительно как порты для приема сообщений.

\subsection{Диспетчер}
Ядро системы ODISP состоит из диспетчера сообщений (stddispatcher) и объектов
реализующих различные стратегии обработки сообщений (порты), интерфейсов ресурсных
объектов и сообщений.

Основные задачи диспетчера объектов:
\begin{itemize}
  \item первоначальный запуск системы, чтение списка объектов и ресурсов
  \item загрузка объектов и ресурсов в порядке их следования в конфигурационном файле
  \item чтение первоначальной конфигурации объектов и ресурсов
  \item отслеживание зависимостей объектов по предоставляемой ими информации
  \item обеспечение конкурентного доступа к ресурсным объектам (блокирующий и не блокирующий
    захват ресурсов)
  \item отслеживание максимально разрешенного количества запущенных экземпляров ресурса
  \item обеспечение корректной выгрузки объектов и ресурсов
\end{itemize}

\subsection{Сообщения}
Каждое сообщение в ODISP идентифицируется своим уникальным (в пределах одного диспетчера 
и виртуальной машины) индексом. Специально зарезервирован номер 0 -- сообщения с этим
номером начинают сессию.

Конверт сообщения содержит поле действия (action), поле отправителя (origin), 
поле получателя (destination) и индекс сообщения, на которое производится ответ.

Сообщение может нести любое количество дополнительных параметров. Смысловая нагрузка параметров
определяется действием (action) и интерпретируется получателем.

Диспетчер не вмешивается в структуру сообщения. Он обеспечивает лишь транспортный уровень.

\subsection{Модули}
Главной единицей в ODISP является модуль (объект ODISP). Именно такой объект реализует
реальную задачу выполняемую системой.

Каждый модуль имеет возможность получать и отсылать любые сообщения в ядре ODISP.
Какие конкретно сообщения будет обрабатывать модуль зависит от стратегии.

\subsection{Ресурсы}
Еще один тип данных с которым работает диспетчер -- ресурс. Объект реализующий
интерфейс ресурса не может получать или посылать ODISP-сообщения. Такой объект
может быть либо хранилищем данных (хранилище в терминах DFD) либо обложкой для внешнего
сложного объекта, которым требуется управлять непосредственно (ресурсы-шлюзы).

Основным назначением ресурсов является именно хранение и, как частный случай, отображение 
данных.

\subsection{Ресурсы-шлюзы}
Ресурсы, работающие в качестве шлюзов реализуют разделяемый доступ к сложным внешним объектам,
которые из-за объема интерфейса проще не инкапсулировать в обычный ресурсный объект.

\section{Реализация}
Текущая реализация объектного диспетчера написана на языке Java версии 1.4.1.

Она содержит в себе набор вспомогательных объектов, которые реализуют базовые
функции. Среди них: консоль управления диспетчером (console), систему файловой журнализации
сообщений (log), объект-эхо (echo) для тестов. Также реализован ресурсный объект обеспечивающий
доступ к простейшему файлу конфигурации (simpleconfig). Эти модули и ресурсы можно использовать
как эталонные реализации отдельных стратегий.


\subsection{Соглашения об именовании}
При работе с ODISP необходимо придерживаться следующих правил именования:
\begin{itemize}
  \item внутреннее имя объекта ODISP должно содержать лишь символы английского алфавита и должно
    нести краткое описание назначения объекта (\verb+devgensnmp+ -- типовое SNMP устройство)
  \item название действия должно начинаться с префикса подсистемы. логические части названия
    должны разделятся символом ``\_'' (\verb+od_remove_dep+ -- убрать зависимость из списка)
  \item для обеспечения возможности загрузки одновременно нескольких одинаковых модулей внутреннее имя
    конструируется из имени модуля и уникального индекса (\verb+log0+, \verb+console1+).
\end{itemize}

\subsection{Стандартный диспетчер}
Текущая реализация диспетчера ODISP (stddispatcher) реализует все поставленные
в модели задачи за исключением отслеживания максимального количества экземпляров
ресурсных объектов. Интерфейс диспетчера так же регистрируется в качестве провайдера
сервиса \verb+dispatcher+.

Запуск системы возможен напрямую из виртуальной машины. В качестве обязательного
параметра диспетчер принимает имя файла содержащего конфигурацию объектов для решения
конкретной задачи.

Загрузка объектов осуществляется в соответствии с их порядком в конфигурационном файле.
Первым всегда запускается модуль обрабатывающий внутренние запросы ядра ODISP: \verb+od_acquire+,
\verb+od_release+, \verb+od_shutdown+ и т.п. 

После загрузки очередного модуля диспетчер запрашивает у объекта список зависимостей и, 
в случае если все зависимости выполнены, запускает объект на выполнение посылкой сообщения
\verb+od_object_loaded+. После запуска диспетчер запрашивает у модуля список сервисов,
которые он предоставляет. Для ресурсных объектов список состоит из одного элемента -- имени
класса.

Конкурирующий доступ объектов к ресурсам обеспечивается за счет хранения очередей заявок 
объектов на ресурсы. При высвобождении ресурса (или в начале работы) из очереди 
выбирается первый ожидающий ресурс. Будет ли захват ресурса блокирующим определяется через
дополнительный параметр запроса ресурса. В то время как статус блокировки объекта определяется
как ``блокированный'', сообщения ODISP для него не отсылаются, а запоминаются в очереди
сообщений. На данный момент существует одно серьезное ограничений -- каждое высвобождение
ресурса считается уменьшением статуса блокировки.

Для обеспечения корректного завершения всеми объектами своей работы при выгрузке системы диспетчер реализует
обработку специального сообщения \verb+od_shutdown+, которая инициирует процесс последовательной выгрузки
объектов с предварительной посылкой им сообщения \verb+od_cleanup+ с необязательным параметром -- кодом
выхода.

\subsection{Стандартное сообщение}
Для передачи сообщений между модулями используются экземпляры класса \verb+StandartMessage+, который
реализует интерфейс \verb+Message+.

Данные в заголовке сообщения представляют собой набор текстовых полей, которые идентифицируют действие,
получателя и отправителя, а так же поле индекса сообщения, на которое производится ответ.

Внутренние данные сообщения представляются в виде словаря с доступом по ключу. Для обеспечения
совместимости, по умолчанию, ключами являются числа начиная с $0$. Никаких действий не 
предпринимается для того, что бы определить и избежать возникновения исключительных ситуаций.

Доставка сообщений производится несколькими однотипными потоками в ядре диспетчера. Обработчики сообщений
вызываются в этих потоках. Следует помнить, что один и тот же обработчик может быть вызван одновременно
из двух или более нитей. На данный момент используется постоянное число нитей (5), между которыми происходит
выбор по принципу первой с наименьшей нагрузкой (least busy round robin).

Для того, что бы определить назначение полей и их тип, получатель должен знать структуру данных
для данного типа действия. Для автоматического приведения типов и замены индексов на некоторые значимые
символьные имена, вводится понятие Typed Messages.

\subsection{Типизированные сообщения}
Типизированные сообщения или Typed Messages помогают привязать логическую нагрузку данных передаваемых
в сообщении к типу действия.

Каждый объект -- типизированное сообщение -- обязан расширять класс \verb+StandartMessage+ для того, 
что бы обеспечить прозрачность работы диспетчера и упростить обработку сообщений, например, при их 
подготовке к передаче по сети.

Для формализации создания типизированных сообщений предлагается использовать соглашения об именовании 
get/set/is методов технологии JavaBeans.

%\subsection{Модули ODISP}

\section{Перспективы развития}
Своей реализации ожидают следующие возможности:
\begin{itemize}
  \item предварительная конфигурация объекта перед запуском на основании данных конфигурационного файла
  \item реализация большего количества примитивных объектов
  \item создание объектов со стратегией обработчиков на основе соглашений об именовании JavaBeans и 
    пакета \verb+java.lang.reflect+
  \item обеспечение совместимости с существующими системами распределенных вычислений (Corba, EJB, COM)
\end{itemize}

\end{document}
