% $Id: odisp-style.tex,v 1.1 2003/12/02 22:07:29 valeks Exp $
\documentclass[a4paper]{article}
\usepackage[koi8-r]{inputenc}
\usepackage[T2C,T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{fancyhdr}
\pagestyle{fancy}
\title{Диспетчер объектов ODISP.}
\author{Валентин А. Алексеев}
\sloppy
\frenchspacing
\begin{document}
\chead{\bfseries НПП ``Новел-ИЛ''}
\vbox{
  \vskip .35 \textheight
  \begin{center}
    Валентин А. Алексеев\\*
    \bfseries{\Large Диспетчер объектов ODISP}
  \end{center}
}
\cfoot{Санкт-Петербург \\* 2003}
\newpage
\chead{}
\cfoot{\thepage}
\tableofcontents
\newpage
\section{Модель}
\subsection{Краткое описание}
ODISP это полностью асинхронная транспортная система без ведения сессий. За основу
были взяты некоторые идеи реализации микроядерных операционных систем и систем 
организации распределенных вычислений.

В основе модели диспетчера объектов лежит метод передачи сообщений между отдельными,
логически цельными, модулями. Каждый модуль имеет связь с диспетчером и почтовый
ящик для приходящих сообщений. Сообщения между модулями служат исключительно для
передачи данных (уведомления). 

Основная деятельность модулей происходит в дочерних объектах. Объекты реализующие 
почтовые ящики стоит воспринимать исключительно как порты для приема сообщений.

Так же ODISP содержит в себе набор вспомогательных объектов, которые реализуют базовые
функции. Среди них: консоль управления диспетчером (console), систему файловой журнализации
сообщений (log), объект-эхо (echo) для тестов. Так же реализован ресурсный объект обеспечивающий
доступ к простейшему файлу конфигурации (simpleconfig).

\subsection{Диспетчер}
Ядро системы ODISP состоит из диспетчера сообщений (stddispatcher) и объектов
обеспечивающих различные стратегии обработки сообщений (порты), интерфейсов ресурсных
объектов и сообщений.

Основной задачи диспетчера объектов:
\begin{itemize}
  \item первоначальный запуск системы, чтение списка объектов и ресурсов
  \item загрузка объектов и ресурсов в порядке их следования в конфигурационном файле
  \item отслеживание зависимостей объектов по предоставляемой ими информацией
  \item обеспечение конкурентного доступа к ресурсным объектам (блокирующий и не блокирующий
    захват ресурсов)
  \item отслеживать максимальное разрешенное количество запущеных экземпляров ресурса
  \item обеспечение корректной выгрузки объектов и ресурсов
\end{itemize}

\subsection{Сообщения}
Каждое сообщение в ODISP идентифицируется своим уникальным (в пределах одного диспетчера 
и вирутальной машины) индексом. Специально зарезервирован номер 0 -- сообщения с этим
номером начинают сессию.

Конверт сообщения содержит поле действия (action), поле отправителя (origin), 
поле получателя (destination) и индекс сообщения на которое производится ответ.

Сообщения могут содержать произвольное количество параметров. Смысловая нагрузка параметров
определяется действием (action) и интерпретируется получателем.

Диспетчер не вмешивается в структуру сообщения. Он обеспечивает лишь транспортный уровень.

\subsection{Модули}
Главной единицей в ODISP является модуль (объект ODISP). Именно такой объект реализует
реальную задачу выполняемую системой.

Каждый модуль имеет возможность получать и отсылать любые сообщения в ядре ODISP.
Какие конкретно сообщения будет обрабатывать модуль зависит от стратегии.

\subsection{Ресурсы}
Еще один тип данных с которым работает диспетчер -- ресурс. Объект реализующий
интерфейс ресурса не может получать или посылать ODISP-сообщения. Такой объект
может быть хранилищем данных (хранилище в терминах DFD) или обложкой для внешнего
сложного объекта, которым требуется управлять непосредственно (прокси-ресурсы).

Основным назначением ресурсов является именно хранение и, как частный случай, отображение 
данных.

\section{Реализация}
Текущая реализация объектного диспетчера написана на языке Java версии 1.4.1.

\subsection{Соглашения об именовании}
При работе с ODISP необходимо придерживатся следующих правил именования:
\begin{itemize}
  \item внутреннее имя объекта ODISP должно содержать лишь символы английского алфавита и должно
    нести краткое описание назначения объекта (\verb+devgensnmp+ -- типовое SNMP устройство)
  \item название действия должно начинатся с префикса подсистемы. логические части названия
    должны разделятся символом ``\_''
\end{itemize}

\subsection{Стандартный диспетчер}
Текущая реализация диспетчера ODISP (stddispatcher) реализует все поставленные
в модели задачи за исключением отслеживания максимального количества экземпляров
ресурсных объектов.

Запуск системы возможен напрямую из виртуальной машины. В качестве обязательного
параметра диспетчер принимает имя файла содержащего конфигурацию объектов для решения
конкретной задачи.

Загрузка объектов осуществляется в соответствии с их порядком в конфигурационном файле.
Первым всегда запускается модуль обрабатывающий внутренние запросы ядра ODISP: \verb+od_acquire+,
\verb+od_release+, \verb+od_shutdown+ и т.п. 

После загрузки очердного модуля диспетчер запрашивает у объекта список зависимостей и, 
в случае если все зависимости выполнены, запускает объект на выполнение посылкой сообщения
\verb+od_object_loaded+. После запуска диспетчер запрашивает у модуля список сервисов,
которые он предоставляет. Для ресурсных объектов список состоит из одного элемента -- имени
класса.

Конкурирующий доступ объектов к ресурсам обеспечивается за счет хранения очередей заявое 
объектов на ресурсы. При высвобождении ресурса (или в начале работы) из очереди 
выбирается первый ожидающий ресурс. Будет ли захват ресурса блокирующим определяется через
дополнительный параметр запроса ресурса. В то время как статус блокировки объекта определяется
как ``блокированный'' сообщения ODISP для него не отсылаются, а запоминаются в очереди
сообщений. На данный момент существует одно серьезное ограничений -- каждое высвобождение
ресурса считается уменьшением статуса блокировки.

Для обеспечения корректного завершения всеми объектами своей работы при выгрузке системы диспетчер реализует
обработку специального сообщения \verb+od_shutdown+, которая инициирует процесс последовательной выгрузки
объектов с предварительной посылкой им сообщения \verb+od_cleanup+ с опциональным параметром -- кодом
выхода.

\subsection{Стандартное сообщение}
Для передачи сообщений между модулями используются экземпляры класса \verb+StandartMessage+, который
реализует интерфейс \verb+Message+.

Данные в заголовке сообщения представляют собой набор текстовых полей, которые идентифицируют действие,
получателя и отправителя, а так же поле индекса сообщения на которое производится ответ.

Внутренне данные сообщения представляются в виде списка с доступом по индексу. Ни каких действий не 
предпринимается для того, что бы определить и избежать возникновения исключительных ситуаций.

Для того, что бы определить назначение полей и их тип получатель должен знать структуру данных
для данного типа действия. Для автоматического приведения типов и замены индеков на некоторые значимые
символьные имена вводится понятие Typed Messages.

\subsection{Типизированные сообщения}
Типизированные сообщения или Typed Messages помогают привязать логическую нагрузку данных передаваемых
в сообщении к типу действия.

Каждый объект-типизированное сообщение обязан расширять класс \verb+StandartMessage+ для того, что бы
обеспечить прозрачность работы диспетчера и упростить обработку сообщений, например, при их подготовке к
передаче по сети.

Для формализации создания типизированных сообщений предлагается использовать соглашения об именовании get/set/is 
методов технологии JavaBeans.

\subsection{Модули}

\subsection{Стратегии обработки}
В текущей реализации определено две основных стратегии обработки сообщений. Каждая из стратегий дает
преимущество для тех или иных задач, которые выполняются модулем. 
Модуль может определить сообщения с каким адресатом он может обрабатывать. Изначально эта маска как
регулярное выражение имеет вид ``\verb+имяобъекта.*+''

\subsubsection{Опросная стратегия}
Модули реализующие опросную модель наследуют класс \verb+PollingODObjcet+ и должны перегрузить
абстрактный метод \verb+handleMessage+.

При использовании данной стратегии именно модуль решает какие из приходящих сообщений он в состоянии
обработать.

\end{document}
