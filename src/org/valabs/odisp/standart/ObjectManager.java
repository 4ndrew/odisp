package org.valabs.odisp.standart;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.doomdark.uuid.UUID;
import org.valabs.odisp.common.Dispatcher;
import org.valabs.odisp.common.Message;
import org.valabs.odisp.common.ODObject;
import org.valabs.stdmsg.ODObjectLoadedMessage;
import org.valabs.stdmsg.ODShutdownMessage;

/**
 * Менеджер объектов ODISP.
 * 
 * @author (C) 2004 <a href="mailto:valeks@novel-il.ru">Valentin A. Alekseev </a>
 * @version $Id: ObjectManager.java,v 1.50 2005/02/17 12:29:10 valeks Exp $
 */

class ObjectManager implements org.valabs.odisp.common.ObjectManager {

  /** Диспетчер объектов. */
  private Dispatcher dispatcher;

  /** Снапшот системы. */
  private DispatcherSnapshot ds = new DispatcherSnapshot();

  /** Хранилище отложенных сообщений. */
  private DefferedMessages messages = new DefferedMessages();

  /** Список объектов. */
  private Map objects = new HashMap();

  /** Журнал. */
  private Logger log = Logger.getLogger(ObjectManager.class.getName());

  /** Список сервисов менеджера. */
  private Map provided = new HashMap();

  /** Пул нитей отсылки. */
  private List senderPool = new ArrayList();

  /** Максимальное количество нитей создаваемых для отсылки изначально. */
  public static final int SENDER_POOL_SIZE = 5;

  /** Хранилище для сообщений. */
  private List messageStorage = new ArrayList();

  /** Ранее загруженный файл hints. */
  private Hints hints = null;

  /**
   * Добавление объекта как провайдера конкретного сервиса.
   * 
   * @param service название сервиса
   * @param objectName название объекта
   */
  public void addProvider(final String service, final String objectName) {
    if (!provided.containsKey(service)) {
      provided.put(service, new ArrayList());
    }
    ((List) provided.get(service)).add(objectName);
  }

  /**
   * Удаление провайдера конкретного сервиса. В случае если у сервиса не остается ни одного провайдера -- он
   * автоматически будет удален.
   * 
   * @param service название сервиса
   * @param objectName название объекта
   */
  public void removeProvider(final String service, final String objectName) {
    if (provided.containsKey(service)) {
      ((List) provided.get(service)).remove(objectName);
      if (((List) provided.get(service)).size() == 0) {
        provided.remove(service);
      }
    }
  }

  /**
   * Проверка на существование провайдеров сервиса.
   * 
   * @param service название сервиса
   * @return флаг присутствия сервиса
   */
  private boolean hasProviders(final String service) {
    return provided.containsKey(service);
  }

  /**
   * Получить список объектов-провайдеров сервиса.
   * 
   * @param service имя сервиса
   * @return немодифицируемый thread-safe список объектов
   */
  private List getProviders(final String service) {
    if (provided.containsKey(service)) {
      return Collections.unmodifiableList(Collections.synchronizedList((List) provided.get(service)));
    } else {
      return null;
    }
  }

  /**
   * Получить список сервисов диспетчера.
   * 
   * @return немодифицируемый список сервисов
   */
  public List getProviding() {
    return new ArrayList(Collections.unmodifiableSet(provided.keySet()));
  }

  /** Попытка подгрузки объектов в следствии изменения списка сервисов менеджера. */
  public final void loadPending() {
    // resources
    Map resourceList = new HashMap(dispatcher.getResourceManager().getResources());
    Iterator it = resourceList.keySet().iterator();
    while (it.hasNext()) {
      String objectName = (String) it.next();
      if (!hasProviders(objectName)) {
        // ресурсы считаются провайдерами сервиса с собственным именем
        addProvider(objectName, objectName);
        log.finest("added resource provider " + objectName);
        hints.addNewHint(objectName);
      }
    }

    Map localObjects = hints.getHintedOrder(objects);
    int statToLoadCount = objects.size();
    while (statToLoadCount != 0) {
      int loaded = 0;
      it = localObjects.keySet().iterator();
      while (it.hasNext()) {
        String objectName = (String) it.next();
        ObjectEntry oe = (ObjectEntry) objects.get(objectName);
        if (oe.isLoaded()) {
          continue;
        }
        log.finest("trying to load object " + objectName);
        // проверка на удовлетворение всех зависимостей
        int totalDependencies = oe.getDepends().size();
        Iterator dit = oe.getDepends().iterator();
        while (dit.hasNext()) {
          String dependency = (String) dit.next();
          if (hasProviders(dependency)) {
            totalDependencies--;
          } else {
            log.finest("dependency not met: " + dependency);
          }

        }

        // все условия зависимости удовлетворены
        if (totalDependencies == 0) {
          // занесение в качестве провайдера для указанных сервисов
          Iterator pit = oe.getProvides().iterator();
          while (pit.hasNext()) {
            String providing = (String) pit.next();
            log.finest("added as provider of " + providing);
            addProvider(providing, objectName);

          }

          // занесение в сервис RECIPIENT_ALL
          addProvider(Message.RECIPIENT_ALL, objectName);
          // если объект хочет получать все сообщения, то занести его в RECIPIENT_CATCHALL
          if (oe.getObject().getMatchAll()) {
            addProvider(Message.RECIPIENT_CATCHALL, objectName);
          }
          // пометка объекта как работающего
          oe.setLoaded(true);
          log.config(" ok. loaded = " + objectName);
          // восстановление данных из слепка если он был
          if (ds.hasSnapshot()) {
            log.config("Restoring state from snapshot for " + objectName);
            oe.getObject().importState(ds.getObjectSnapshot(objectName));
          }
          // официальное уведомление объекта о загрузке
          Message m = dispatcher.getNewMessage();
          ODObjectLoadedMessage.setup(m, objectName, UUID.getNullUUID());
          m.setDestination(objectName);
          oe.getObject().handleMessage0(m);
          // сброс накопившихся сообщений
          flushDefferedMessages(objectName);
          // запись в hints файл в случае необходимости
          if (oe.isIntoHints()) {
            hints.addNewHint(oe.getObject().getClass().getName());
          }
          statToLoadCount--;
          loaded++;
        }
      }
      if (loaded == 0) {
        log.warning("Some of the objects failed to load. There is something wrong with dependencies.");
        break;
      }
    }
    if (statToLoadCount == 0) {
      hints.storeHints();
      ds.clearSnapshot();
    }
  }

  /**
   * Динамическая загрузка объекта (с учётом зависимостей). Сохранение порядка в hints включено.
   * 
   * @param cName имя загружаемого класса
   * @param configuration список параметров загрузки
   */
  public final void loadObject(final String cName, final Map configuration) {
    if (cName.equals(DispatcherHandler.class.getName())) {
      /** @todo. плохой хак. */
      loadObject(cName, configuration, false);
      return;
    }
    loadObject(cName, configuration, true);
  }

  /**
   * Динамическая загрузка объекта (с учётом зависимостей).
   * 
   * @param cName имя загружаемого класса
   * @param configuration список параметров загрузки
   * @param intoHints сохранять ли запись в файл hints
   */
  public final void loadObject(final String cName, final Map configuration, final boolean intoHints) {
    log.config("loading object " + cName);
    try {
      ODObject load = (ODObject) Class.forName(cName).newInstance();
      load.setDispatcher(new SecureDispatcher(dispatcher, load.getObjectName()));
      load.setConfiguration(configuration);
      ObjectEntry oe = new ObjectEntry(cName, load.getDepends(), load.getProviding());
      oe.setObject(load);
      oe.setLoaded(false);
      oe.setIntoHints(intoHints);
      synchronized (objects) {
        objects.put(load.getObjectName(), oe);
      }
    } catch (Exception e) {
      dispatcher.getExceptionHandler().signalException(e);
    }
  }

  /**
   * Выгрузка объекта с учётом зависимых.
   * <ul>
   * <li>Составление списка зависимых объектов
   * <li>Удаление зависимых объектов
   * <li>Сохранение статуса объекта, в случае если происходит перезагрузка диспетчера
   * <li>Удаление самого объекта
   * </ul>
   * 
   * @param objectName внутреннее имя объекта для удаления.
   * @param code код выхода (при code != 0 зависимые объекты не удаляются).
   */
  public synchronized final void unloadObject(final String objectName, final int code) {
    if (objects.containsKey(objectName)) {
      ObjectEntry oe = (ObjectEntry) objects.get(objectName);
      Set provides = oe.getProvides();
      Iterator it = objects.keySet().iterator();
      Set dependingObjs = new HashSet();

      // поиск зависимых объектов
      while (it.hasNext()) {
        String depObjectName = (String) it.next();
        Set depends = ((ObjectEntry) objects.get(depObjectName)).getDepends();
        Iterator pit = provides.iterator();
        while (pit.hasNext()) {
          String element = (String) pit.next();
          if (depends.contains(element)) {
            dependingObjs.add(depObjectName);
          }
        }
      }

      // удаление из списка сервисов
      it = provides.iterator();
      while (it.hasNext()) {
        String element = (String) it.next();
        removeProvider(element, objectName);
      }

      // выгрузка зависимых объектов
      it = dependingObjs.iterator();
      while (it.hasNext()) {
        String className = (String) it.next();
        if (objects.containsKey(className)) {
          log.finest("removing " + objectName + "'s dependency " + className);
          unloadObject(className, code);
        }
      }

      // сигнализация завершения работы
      oe.getObject().cleanUp(code);

      // сохранение слепка объекта, в случае если происходит перезапуск диспетчера
      if (code == ODShutdownMessage.SHUTDOWN_RESTART) {
        if (ds == null) {
          ds = new DispatcherSnapshot();
        }
        ds.addObjectSnapshot(objectName, oe.getObject().exportState());
      }

      // удаление объекта
      objects.remove(objectName);
      log.config("object " + objectName + " unloaded");
    }
  }

  /**
   * Доступ к списку объектов.
   * 
   * @return список объектов
   */
  public final Map getObjects() {
    return objects;
  }

  /**
   * Констурктор менеджера.
   * 
   * @param newDispatcher диспетчер для которого производится управление ресурсами
   */
  public ObjectManager(final Dispatcher newDispatcher) {
    dispatcher = newDispatcher;
    log.setLevel(Level.FINE);
    for (int i = 0; i < SENDER_POOL_SIZE; i++) {
      senderPool.add(new Sender(this));
    }
    hints = new Hints();
  }

  /**
   * Послать сообщение конкретному объекту.
   * 
   * @param objectName имя объекта
   * @param message сообщение
   */
  private void sendToObject(final String objectName, final Message message) {
    ObjectEntry oe = null;
    // исключить модификацию списка дескрипторов объектов
    synchronized (objects) {
      oe = (ObjectEntry) objects.get(objectName);
    }
    if (oe == null) { return; }
    ODObject objToSendTo = null;
    // исключить модификацию дескриптора состояние объекта
    synchronized (oe) {
      if (!oe.isLoaded()) {
        log.finest("deffered message " + message.getAction() + " for " + objectName);
        messages.addMessage(objectName, message);
        return;
      }
      objToSendTo = oe.getObject();
    }
    synchronized (messageStorage) {
      if (message.isOOB()) {
        log.finest("Sending OOB message " + message);
        messageStorage.add(0, new SendRecord(message, objToSendTo));
      } else {
        messageStorage.add(new SendRecord(message, objToSendTo));
      }
    }
  }

  /**
   * Посылка сообщения всем объектам менеджера.
   * 
   * @param message сообщение
   */
  public final void send(Message message) {
    if (message == null || message.getAction().length() == 0 || !message.isCorrect()) { return; }

    // рассылка реальным адресатам
    Iterator it;
    Set recipients = new HashSet();
    if (getProviders(message.getDestination()) != null) {
      recipients.addAll(getProviders(message.getDestination()));
    }
    if (getProviders(Message.RECIPIENT_CATCHALL) != null) {
      recipients.addAll(getProviders(Message.RECIPIENT_CATCHALL));
    }
    if (recipients.size() > 0) {
      it = recipients.iterator();
      Message actualMessage;
      while (it.hasNext()) {
        String objectName = (String) it.next();
        actualMessage = message.cloneMessage();
        actualMessage.setDestination(objectName);
        sendToObject(objectName, actualMessage);
      }
    }
  }

  /**
   * Сброс записанных сообщений при снятии блокировки с объекта.
   * 
   * @param objectName имя объекта
   */
  private void flushDefferedMessages(final String objectName) {
    if (!objects.containsKey(objectName)) { return; }
    List toFlush = messages.flush(objectName);
    Iterator it = toFlush.iterator();
    while (it.hasNext()) {
      sendToObject(objectName, (Message) it.next());
    }
    loadPending();
  }

  /** Получение следующего сообщения для обработки. */
  final SendRecord getNextPendingMessage() {
    SendRecord toSend = null;
    synchronized (messageStorage) {
      if (messageStorage.size() > 0) {
        toSend = (SendRecord) messageStorage.get(0);
        messageStorage.remove(0);
      }
      if (ds != null) {
        // XXX: проблема -- ds создаётся только после запуска всех объектов
        // но к этому моменту уже могут существовать сообщения кроме ODObjectLoaded!
        ds.setMessageQueue(messageStorage);
      }
    }
    return toSend;
  }

  public final void signalException(Exception e) {
    dispatcher.getExceptionHandler().signalException(e);
  }

  class Hints {

    private List oldHints = new ArrayList();
    private List newHints = new ArrayList();

    public void addNewHint(String object) {
      newHints.add(object);
    }
    
    public Hints() {
      try {
        BufferedReader in = new BufferedReader(new FileReader("hints"));
        String s = in.readLine();
        while (s != null) {
          oldHints.add(s);
          s = in.readLine();
        }
      } catch (IOException e) {
      }
    }

    public Map getHintedOrder(Map objects) {
      Map localObjects;
      if (oldHints.size() > 0) {
        localObjects = new TreeMap(new HintsOrderComparator(oldHints));
      } else {
        localObjects = new HashMap();
      }
      synchronized (objects) {
        localObjects.putAll(objects);
      }
      return localObjects;
    }

    /**
     * 
     */
    public void storeHints() {
      Iterator it;
      // вывести удачный порядок загрузки.
      String msg = "\n============================================\n";
      if (newHints.size() > 0) {
        msg += "Result hints file:\n";
        /** @todo. HACK файл hints пишется в текущий каталог, что не есть гут. */
        try {
          File hintsFile = new File("hints");
          hintsFile.createNewFile();
          PrintStream out = new PrintStream(new FileOutputStream(hintsFile));
          it = newHints.iterator();
          while (it.hasNext()) {
            String elt = (String) it.next();
            out.println(elt);
            msg += "\t" + elt + "\n";
          }
        } catch (IOException e) {
          log.warning("Unable to write hints file.");
          dispatcher.getExceptionHandler().signalException(e);
        }
        msg += "Total: " + newHints.size() + "\n";
        msg += "============================================\n";
        log.fine(msg);
      }
    }

    class HintsOrderComparator implements Comparator {
      private List hints;
      
      public HintsOrderComparator(List _hints) {
        hints = _hints;
      }
      
      public int compare(Object _o1, Object _o2) {
        String o1 = ((ObjectEntry) objects.get(_o1)).getClassName();
        String o2 = ((ObjectEntry) objects.get(_o2)).getClassName();
        if (o1.equals(o2)) { return 0; }
        if (o1.equals(DispatcherHandler.class.getName())) { return 1; }
        if (o2.equals(DispatcherHandler.class.getName())) { return -1; }
        if (hints != null) {
          if (hints.contains(o1) && hints.contains(o2)) {
            return (hints.indexOf(o1) < hints.indexOf(o2)) ? -1 : 1;
          } else if (hints.contains(o1)) {
            return 1;
          } else if (hints.contains(o2)) { return -1; }
        }
        return 0;
      }
    }
  }
} // StandartObjectManager
